# 使用技术 webpack + jquery + typescript + 面向对象的开发方式
# 学习到TS + webpack，可以巩固ts知识，锻炼开发思维
# 浏览器环境 + 模块化
# webpack
- 会根据入口来寻找依赖，进行构建打包
- npm init 初始化工程
- npm i webpack webpack-cli 安装webpack
- webpack.config.js，建立 webpack 打包配置文件
- webpack-dev-server 开发时的服务器，保存自动刷新
- 处理ts，要安装ts-loader；

# 开发之前，一些面向对象的原则要根深蒂固
单一原则：每个类只能做跟它相关的一件事情，外部怎么使用你不用管。
开闭原则：系统中的类，应该对外扩展，对修改关闭。（尽量不要修改类本身）

基于以上两个原则进行OOP编程
数据-界面分离模式（react其实也是这样，数据界面相分离，展示组件只关心渲染数据，容器组件只关心数据）
传统OOP写类时，所有的属性全部私有化，使用公开的方法提供对属性的访问（java 就是如此）

# 小方块类 Square
- 小方块类有什么？
- 有什么样的属性？颜色（color），坐标（x, y）
- 不要去想界面的坐标，这里是逻辑坐标！！！
- 什么是逻辑坐标？就是根据面板，来相对的对面板划分区块！！！
- 传统的面向对象语言书写属性，全部私有化，使用公开的方法提供对属性的访问；java就是这样；
- 为什么要这样写？OOP 封装
- 系统到处都需要一个坐标，那么坐标就可以抽象成一个类型 interface Point { x:number, y:number }
- 小方块类不知道什么时候显示，它并不知道怎么显示；但它知道什么时候显示；
- 那它什么时候显示呢？数据改变了就显示，增加一个可选的显示者IViewer。调用显示方法;
- IViewer 做成类或者接口都可以，但是它必须有两个方法show, remove
- 像 react 处理核心逻辑；react-dom处理显示；
- 这样一来，小方块类就对外可扩展，你只要实现IViewer就可以了；对内关闭，不需要修改内部的东西，设置坐标的时候直接调用显示者的显示方法就行了；

# 小方块显示者类
- 作用：用于显示一个小方块到页面上
- 那显示者有什么属性和方法呢？
- 首先你要告诉我显示的小方块，还要告诉我容器。（容器是什么？dom 对象，HTMLElement）
- 那你要显示啥，就直接去实现啥，这里直接实现 IViewer 显示者就行了
- 这里就很巧妙了，通过接口的契约，把数据处理类Square 和 小方块显示类给联系起来了
- 只依赖接口，不依赖具体实现的东西；
- 这样，在显示者类里面创建一个jq dom对象属性，调用显示show的时候，显示这个dom对象就可以了
- 但是这个dom 对象显示的宽高，是可配置的，PageConfig，这个配置文件跟显示相关的；
- 这样，数据方块类Square 和 页面显示类 SquarePageViewer 就可以达到数据页面相分离了；没有强关联，通过契约接口来联系；这样代码级别的强约束，是非常舒服的。

# 方块组合类（有点难）
组合的形状，由一组小方块类组成；初始化就固定了（一组相对坐标的组合，该组合中有一个特殊的坐标，表示形状的中心）
如果知道形状，中心点坐标（相对面板的中心点），颜色。就可以设置小方块数组了。
面向对象是渐进式的开发，以一个类来慢慢添加属性和方法。就以方块的组合类来说
private _shape: Shape,       //形状，储存相对位置的小方块（中心点是x:0, y:0）
private _centerPoint: Point, //中心点坐标，巧妙的利用相对位置，让形状都加上中心点坐标就可以描述出形状了
private _color: string
# 细节：然后根据访问器，set中心点坐标同时设置小方块数组的坐标，达到了形状下落的整个过程。

# 俄罗斯生产者类(Teris)
- 实际情况俄罗斯方块形状进行预定义
- 随机产生俄罗斯方块Group
- 创建一个utils，产生随机数（dec + min）, 随机获取形状，颜色；
- 导出一个createTeris({x:3, y:3})，只需要传入中心点坐标就可以完成俄罗斯方块的创建；

# 俄罗斯方块规则类 TerisRule.ts （核心难点）
根据游戏规则提供一系列的函数
- canIMove 先判断能不能移动，怎么判断呢，需要传目标点坐标，和形状，如果至少有一个超出面板边界，就不能移动。根据panelSize.width、height 来判断
- move 移动小方块

# 旋转功能
本质就是根据当前形状改变形状，
- 如果是顺时针旋转，(x, y) -> (-y, x)；逆时针就是 (x, y) -> (y, -x)；
afterRotateShape() -> 得到新的形状
有些方块是不旋转的；有些是只有两种旋转状态；
rotate 方法是一种通用的实现，但是，不同的情况下，会有不同的实现方式
用继承，将SquareGroup作为父类，其它的方块都是它的子类，子类可以重写父类的方法
这也是面向对象的一些实现方式，不去更改原来的代码，原来的类，用继承；    
tips: 写函数的时候，尽量写成单一职责。就是只关心一件事，不耦合多个功能，这样写的好处就是复用！！！；









